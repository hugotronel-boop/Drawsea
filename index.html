<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ðŸŽ¹ SynthÃ© Tactile</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1>ðŸŽ¹ SynthÃ© Tactile</h1>
<p>Pose un doigt et glisse pour jouer !</p>
<canvas id="canvas"></canvas>
<script src="script.js"></script>
</body>
</html><style>html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #111;
  color: white;
  font-family: sans-serif;
  touch-action: none;
}

h1, p {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  z-index: 10;
}

h1 { top: 10px; }
p { top: 40px; }

canvas {
  display: block;
}</style><script>const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let audioCtx = null; // crÃ©Ã© au premier touch
const touches = {};  // stocke chaque doigt

// gÃ©nÃ©rer couleur unique par doigt
function getColor(id) {
  const hue = (id * 50) % 360;
  return `hsl(${hue}, 100%, 60%)`;
}

// crÃ©er un oscillateur pour un doigt
function createOscillator(id, x, y) {
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  osc.type = "sine";
  osc.frequency.setValueAtTime(200 + (x / canvas.width) * 1000, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(1 - y / canvas.height, audioCtx.currentTime);

  osc.connect(gainNode).connect(audioCtx.destination);
  osc.start();

  touches[id] = {
    osc,
    gainNode,
    lastX: x,
    lastY: y,
    color: getColor(id)
  };
}

// ===============================
// DRAW TOUCHES + TRAÃŽNÃ‰ES
// ===============================
function draw() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for(let id in touches){
    const t = touches[id];
    // traÃ®nÃ©e
    ctx.beginPath();
    ctx.arc(t.lastX, t.lastY, 30, 0, Math.PI*2);
    ctx.fillStyle = t.color;
    ctx.fill();
  }

  requestAnimationFrame(draw);
}
draw();

// ===============================
// TOUCH HANDLERS
// ===============================
canvas.addEventListener("touchstart", e=>{
  e.preventDefault();
  for(let t of e.changedTouches){
    createOscillator(t.identifier, t.clientX, t.clientY);
  }
});

canvas.addEventListener("touchmove", e=>{
  e.preventDefault();
  for(let t of e.changedTouches){
    if(touches[t.identifier]){
      const td = touches[t.identifier];

      // frÃ©quence X
      let freq = 200 + (t.clientX / canvas.width) * 1000;

      // modulation vitesse
      const dx = t.clientX - td.lastX;
      const dy = t.clientY - td.lastY;
      const speed = Math.sqrt(dx*dx + dy*dy);
      freq += speed;

      td.osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

      // volume Y
      td.gainNode.gain.setValueAtTime(1 - t.clientY / canvas.height, audioCtx.currentTime);

      td.lastX = t.clientX;
      td.lastY = t.clientY;
    }
  }
});

canvas.addEventListener("touchend", e=>{
  e.preventDefault();
  for(let t of e.changedTouches){
    if(touches[t.identifier]){
      touches[t.identifier].osc.stop();
      delete touches[t.identifier];
    }
  }
});

canvas.addEventListener("touchcancel", e=>{
  e.preventDefault();
  for(let t of e.changedTouches){
    if(touches[t.identifier]){
      touches[t.identifier].osc.stop();
      delete touches[t.identifier];
    }
  }
});</script>
